<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>WebSocket | Lzh正在写代码</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="一、  简介1.1 什么是WebSocketWebSocket是一种协议，用于在Web应用程序和服务器之间建立实时、双向的通信连接。它通过一个单一的TCP连接提供了持久化连接，这使得Web应用程序可以更加实时地传递数据。WebSocket协议最初由W3C开发，并于2011年成为标准。 1.2 WebSocket的优势和劣势WebSocket的优势包括：  实时性： 由于WebSocket的持久化连">
<meta property="og:type" content="article">
<meta property="og:title" content="WebSocket">
<meta property="og:url" content="http://example.com/2025/03/28/WebSocket/index.html">
<meta property="og:site_name" content="Lzh正在写代码">
<meta property="og:description" content="一、  简介1.1 什么是WebSocketWebSocket是一种协议，用于在Web应用程序和服务器之间建立实时、双向的通信连接。它通过一个单一的TCP连接提供了持久化连接，这使得Web应用程序可以更加实时地传递数据。WebSocket协议最初由W3C开发，并于2011年成为标准。 1.2 WebSocket的优势和劣势WebSocket的优势包括：  实时性： 由于WebSocket的持久化连">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i-blog.csdnimg.cn/blog_migrate/52fc058e72b460c21aaabee1551d0a97.jpeg">
<meta property="article:published_time" content="2025-03-28T04:39:21.000Z">
<meta property="article:modified_time" content="2025-03-28T08:40:25.213Z">
<meta property="article:author" content="Lzh">
<meta property="article:tag" content="Web">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i-blog.csdnimg.cn/blog_migrate/52fc058e72b460c21aaabee1551d0a97.jpeg">
  
    <link rel="alternate" href="/atom.xml" title="Lzh正在写代码" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Lzh正在写代码</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS 订阅"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="搜索"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-WebSocket" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/03/28/WebSocket/" class="article-date">
  <time class="dt-published" datetime="2025-03-28T04:39:21.000Z" itemprop="datePublished">2025-03-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Web/">Web</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      WebSocket
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="一、-简介"><a href="#一、-简介" class="headerlink" title="一、  简介"></a>一、  简介</h3><h4 id="1-1-什么是WebSocket"><a href="#1-1-什么是WebSocket" class="headerlink" title="1.1 什么是WebSocket"></a>1.1 什么是WebSocket</h4><p>WebSocket是一种协议，用于在Web应用程序和服务器之间建立实时、<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%8F%8C%E5%90%91%E7%9A%84&spm=1001.2101.3001.7020">双向的</a>通信连接。它通过一个单一的TCP连接提供了持久化连接，这使得Web应用程序可以更加实时地传递数据。WebSocket协议最初由W3C开发，并于2011年成为标准。</p>
<h4 id="1-2-WebSocket的优势和劣势"><a href="#1-2-WebSocket的优势和劣势" class="headerlink" title="1.2 WebSocket的优势和劣势"></a>1.2 WebSocket的优势和劣势</h4><p><strong>WebSocket的优势包括：</strong></p>
<ul>
<li><strong>实时性：</strong> 由于WebSocket的持久化连接，它可以实现实时的数据传输，避免了Web应用程序需要不断地发送请求以获取最新数据的情况。</li>
<li><strong>双向通信：</strong> WebSocket协议支持双向通信，这意味着服务器可以主动向客户端发送数据，而不需要客户端发送请求。</li>
<li><strong>减少网络负载：</strong> 由于WebSocket的持久化连接，它可以减少HTTP请求的数量，从而减少了网络负载。</li>
</ul>
<p><strong>WebSocket的劣势包括：</strong></p>
<ul>
<li><strong>需要浏览器和服务器都支持：</strong> WebSocket是一种相对新的技术，需要浏览器和服务器都支持。一些旧的浏览器和服务器可能不支持WebSocket。</li>
<li><strong>需要额外的开销：</strong> WebSocket需要在服务器上维护长时间的连接，这需要额外的开销，包括内存和CPU。</li>
<li><strong>安全问题：</strong> 由于WebSocket允许服务器主动向客户端发送数据，可能会存在安全问题。服务器必须保证只向合法的客户端发送数据。</li>
</ul>
<h3 id="二、-WebSocket的基本概念"><a href="#二、-WebSocket的基本概念" class="headerlink" title="二、 WebSocket的基本概念"></a>二、 WebSocket的基本概念</h3><h4 id="2-1-WebSocket的协议"><a href="#2-1-WebSocket的协议" class="headerlink" title="2.1 WebSocket的协议"></a>2.1 WebSocket的协议</h4><p>[WebSocket 协议](<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=WebSocket">https://so.csdn.net/so/search?q=WebSocket</a> 协议&amp;spm&#x3D;1001.2101.3001.7020)是一种基于TCP的协议，用于在客户端和服务器之间建立持久连接，并且可以在这个连接上实时地交换数据。WebSocket协议有自己的握手协议，用于建立连接，也有自己的数据传输格式。</p>
<p>当客户端发送一个 WebSocket 请求时，服务器将发送一个协议响应以确认请求。在握手期间，客户端和服务器将协商使用的协议版本、支持的子协议、支持的扩展选项等。一旦握手完成，连接将保持打开状态，客户端和服务器就可以在连接上实时地传递数据。</p>
<p>WebSocket 协议使用的是双向数据传输，即客户端和服务器都可以在任意时间向对方发送数据，而不需要等待对方的请求。它支持二进制数据和文本数据，可以自由地在它们之间进行转换。</p>
<p>总之，WebSocket协议是一种可靠的、高效的、双向的、持久的通信协议，它适用于需要实时通信的Web应用程序，如在线游戏、实时聊天等。</p>
<h4 id="2-2-WebSocket的生命周期"><a href="#2-2-WebSocket的生命周期" class="headerlink" title="2.2 WebSocket的生命周期"></a>2.2 WebSocket的生命周期</h4><p>WebSocket 生命周期描述了 WebSocket 连接从创建到关闭的过程。一个 WebSocket 连接包含以下四个主要阶段：</p>
<ul>
<li><strong>连接建立阶段（Connection Establishment）：</strong> 在这个阶段，客户端和服务器之间的 WebSocket 连接被建立。客户端发送一个 WebSocket 握手请求，服务器响应一个握手响应，然后连接就被建立了。</li>
<li><strong>连接开放阶段（Connection Open）：</strong> 在这个阶段，WebSocket 连接已经建立并开放，客户端和服务器可以在连接上互相发送数据。</li>
<li><strong>连接关闭阶段（Connection Closing）：</strong> 在这个阶段，一个 WebSocket 连接即将被关闭。它可以被客户端或服务器发起，通过发送一个关闭帧来关闭连接。</li>
<li><strong>连接关闭完成阶段（Connection Closed）：</strong> 在这个阶段，WebSocket 连接已经完全关闭。客户端和服务器之间的任何交互都将无效。</li>
</ul>
<blockquote>
<p>“</p>
<p>需要注意的是，WebSocket 连接在任何时候都可能关闭，例如网络故障、服务器崩溃等情况都可能导致连接关闭。因此，需要及时处理 WebSocket 连接关闭的事件，以确保应用程序的可靠性和稳定性。</p>
</blockquote>
<p>下面是一个简单的 WebSocket 生命周期示意图：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/52fc058e72b460c21aaabee1551d0a97.jpeg" alt="图片"></p>
<p>图片</p>
<p>在这个示意图中，客户端向服务器发送一个 WebSocket 握手请求，服务器响应一个握手响应，连接就被建立了。一旦连接建立，客户端和服务器就可以在连接上互相发送数据，直到其中一方发送一个关闭帧来关闭连接。在关闭帧被接收后，连接就会被关闭，WebSocket 连接关闭完成。</p>
<h4 id="2-3-WebSocket的消息格式"><a href="#2-3-WebSocket的消息格式" class="headerlink" title="2.3 WebSocket的消息格式"></a>2.3 WebSocket的消息格式</h4><p>WebSocket 的消息格式与 HTTP 请求和响应的消息格式有所不同。WebSocket 的消息格式可以是文本或二进制数据，并且 WebSocket 消息的传输是在一个已经建立的连接上进行的，因此不需要再进行 HTTP 请求和响应的握手操作。</p>
<p>WebSocket 消息格式由两个部分组成：消息头和消息体。</p>
<p>消息头包含以下信息：</p>
<ul>
<li><strong>FIN：</strong> 表示这是一条完整的消息，一般情况下都是1。</li>
<li><strong>RSV1、RSV2、RSV3：</strong> 暂时没有使用，一般都是0。</li>
<li><strong>Opcode：</strong> 表示消息的类型，包括文本消息、二进制消息等。</li>
<li><strong>Mask：</strong> 表示消息是否加密。</li>
<li><strong>Payload length：</strong> 表示消息体的长度。</li>
<li><strong>Masking key：</strong> 仅在消息需要加密时出现，用于对消息进行解密。</li>
</ul>
<p>消息体就是实际传输的数据，可以是文本或二进制数据。</p>
<h4 id="2-4-WebSocket的API"><a href="#2-4-WebSocket的API" class="headerlink" title="2.4 WebSocket的API"></a>2.4 WebSocket的API</h4><p>WebSocket API 是用于在 Web 应用程序中创建和管理 WebSocket 连接的接口集合。WebSocket API 由浏览器原生支持，无需使用额外的 JavaScript 库或框架，可以直接在 JavaScript 中使用。</p>
<p>下面是一些常用的 WebSocket API：</p>
<p><strong>WebSocket 构造函数：</strong> WebSocket 构造函数用于创建 WebSocket 对象。它接受一个 URL 作为参数，表示要连接的 WebSocket 服务器的地址。例如：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">&#x27;ws://example.com/ws&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>WebSocket.send() 方法：</strong> <code>WebSocket.send()</code> 方法用于向服务器发送数据。它接受一个参数，表示要发送的数据。数据可以是字符串、Blob 对象或 ArrayBuffer 对象。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ws.send(&#x27;Hello, server!&#x27;);</span><br></pre></td></tr></table></figure>

<p><strong>WebSocket.onopen 事件：</strong> <code>WebSocket.onopen</code> 事件在 WebSocket 连接成功建立时触发。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ws.<span class="property">onopen</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;WebSocket 连接已经建立。&#x27;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>WebSocket.onmessage 事件：</strong> <code>WebSocket.onmessage</code> 事件在接收到服务器发送的消息时触发。它的 event 对象包含一个 data 属性，表示接收到的数据。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ws.<span class="property">onmessage</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;收到服务器消息：&#x27;</span>, event.<span class="property">data</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>WebSocket.onerror 事件：</strong> <code>WebSocket.onerror</code> 事件在 WebSocket 连接出现错误时触发。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ws.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;WebSocket 连接出现错误：&#x27;</span>, event);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>WebSocket.onclose 事件：</strong> <code>WebSocket.onclose</code> 事件在 WebSocket 连接被关闭时触发。例如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ws.onclose = function() &#123;</span><br><span class="line">  console.log(&#x27;WebSocket 连接已经关闭。&#x27;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>以上是一些常用的 WebSocket API。</p>
<h3 id="三、-在Java中使用WebSocket"><a href="#三、-在Java中使用WebSocket" class="headerlink" title="三、 在Java中使用WebSocket"></a>三、 在Java中使用WebSocket</h3><p>依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.websocket<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.websocket-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="3-1-使用Java-WebSocket-API编写WebSocket服务端"><a href="#3-1-使用Java-WebSocket-API编写WebSocket服务端" class="headerlink" title="3.1 使用Java WebSocket API编写WebSocket服务端"></a>3.1 使用Java WebSocket API编写WebSocket服务端</h4><p>下面是一个使用 Java WebSocket API 编写 WebSocket 服务端的示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.websocket.*;</span><br><span class="line"><span class="keyword">import</span> javax.websocket.server.ServerEndpoint;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ServerEndpoint(&quot;/echo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EchoServer</span> &#123;</span><br><span class="line">    <span class="meta">@OnOpen</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onOpen</span><span class="params">(Session session)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;WebSocket 连接已经建立。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnMessage</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(String message, Session session)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;收到客户端消息：&quot;</span> + message);</span><br><span class="line">        session.getBasicRemote().sendText(<span class="string">&quot;服务器收到消息：&quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@OnClose</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClose</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;WebSocket 连接已经关闭。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@OnError</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(Throwable t)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;WebSocket 连接出现错误：&quot;</span> + t.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个示例代码定义了一个名为 “echo” 的 WebSocket 端点，它会监听客户端发来的消息，并将收到的消息返回给客户端。具体来说，它使用了 <code>@ServerEndpoint</code> 注解来指定 WebSocket 端点的 URL，使用了 <code>@OnOpen</code>、<code>@OnMessage</code>、<code>@OnClose</code> 和 <code>@OnError</code> 注解来定义 WebSocket 事件处理器。</p>
<p>要使用这个 WebSocket 服务端，我们需要部署它到一个支持 WebSocket 的 Web 容器中。例如，我们可以使用 Tomcat 8 或以上版本来运行它。在部署完成后，我们可以使用任何支持 WebSocket 的客户端来连接这个服务端，发送消息并接收服务器的响应。</p>
<p>例如，下面是一个简单的 HTML&#x2F;JavaScript 客户端代码：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>WebSocket Demo<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> ws = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="string">&#x27;ws://localhost:8080/echo&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        ws.<span class="property">onopen</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;WebSocket 连接已经建立。&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">            ws.<span class="title function_">send</span>(<span class="string">&#x27;Hello, server!&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;;</span></span><br><span class="line"><span class="language-javascript">        ws.<span class="property">onmessage</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;收到服务器消息：&#x27;</span>, event.<span class="property">data</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;;</span></span><br><span class="line"><span class="language-javascript">        ws.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;WebSocket 连接出现错误：&#x27;</span>, event);</span></span><br><span class="line"><span class="language-javascript">        &#125;;</span></span><br><span class="line"><span class="language-javascript">        ws.<span class="property">onclose</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;WebSocket 连接已经关闭。&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;;</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>WebSocket Demo<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这个客户端使用了 WebSocket 构造函数来创建一个 WebSocket 对象，并指定连接的 URL 为我们之前部署的服务端的 URL。它使用了 WebSocket 的事件处理器来处理 WebSocket 事件，例如当 WebSocket 连接成功建立时，它会向服务器发送一条消息，并在收到服务器的响应时打印出消息内容。</p>
<h4 id="3-2-使用Java-WebSocket-API编写WebSocket客户端"><a href="#3-2-使用Java-WebSocket-API编写WebSocket客户端" class="headerlink" title="3.2 使用Java WebSocket API编写WebSocket客户端"></a>3.2 使用Java WebSocket API编写WebSocket客户端</h4><p>下面是一个使用 Java WebSocket API 编写 WebSocket 客户端的示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.websocket.*;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.URI;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ClientEndpoint</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EchoClient</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Session session;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnOpen</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onOpen</span><span class="params">(Session session)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;WebSocket 连接已经建立。&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.session = session;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnMessage</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(String message, Session session)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;收到服务器消息：&quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnClose</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClose</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;WebSocket 连接已经关闭。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnError</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(Throwable t)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;WebSocket 连接出现错误：&quot;</span> + t.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">(String url)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">WebSocketContainer</span> <span class="variable">container</span> <span class="operator">=</span> ContainerProvider.getWebSocketContainer();</span><br><span class="line">        container.connectToServer(<span class="built_in">this</span>, <span class="keyword">new</span> <span class="title class_">URI</span>(url));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(String message)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        session.getBasicRemote().sendText(message);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        session.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-3-使用Spring-Boot编写WebSocket服务端"><a href="#3-3-使用Spring-Boot编写WebSocket服务端" class="headerlink" title="3.3 使用Spring Boot编写WebSocket服务端"></a>3.3 使用Spring Boot编写WebSocket服务端</h4><h5 id="创建Spring-Boot项目"><a href="#创建Spring-Boot项目" class="headerlink" title="创建Spring Boot项目"></a>创建Spring Boot项目</h5><p>首先，您需要创建一个新的Spring Boot项目。可以使用Spring Initializr创建一个新项目，添加依赖项。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-websocket<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="配置WebSocket"><a href="#配置WebSocket" class="headerlink" title="配置WebSocket"></a>配置WebSocket</h5><p>应用程序中，需要配置WebSocket。创建一个新的Java类，并添加注释<code>@ServerEndpoint(&quot;/websocket&quot;)</code>。这将指定WebSocket服务端的端点。</p>
<p>在此类中，需要实现几个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.websocket.OnClose;</span><br><span class="line"><span class="keyword">import</span> javax.websocket.OnMessage;</span><br><span class="line"><span class="keyword">import</span> javax.websocket.OnOpen;</span><br><span class="line"><span class="keyword">import</span> javax.websocket.Session;</span><br><span class="line"><span class="keyword">import</span> javax.websocket.server.ServerEndpoint;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ServerEndpoint(&quot;/websocket&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSocketServer</span> &#123;</span><br><span class="line">    <span class="meta">@OnOpen</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onOpen</span><span class="params">(Session session)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Connection opened: &quot;</span> + session.getId());</span><br><span class="line">        sessions.add(session);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnMessage</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(Session session, String message)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Received message: &quot;</span> + message);</span><br><span class="line">        session.getBasicRemote().sendText(<span class="string">&quot;Server received: &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnClose</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClose</span><span class="params">(Session session)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Connection closed: &quot;</span> + session.getId());</span><br><span class="line">        sessions.remove(session);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;Session&gt; sessions = Collections.synchronizedSet(<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Session&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="处理WebSocket消息"><a href="#处理WebSocket消息" class="headerlink" title="处理WebSocket消息"></a>处理WebSocket消息</h5><p>在<code>@OnMessage</code>方法中，可以处理WebSocket客户端发送的消息，并向客户端发送响应。下面是一个简单的示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@OnMessage</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(Session session, String message)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Received message: &quot;</span> + message);</span><br><span class="line">    session.getBasicRemote().sendText(<span class="string">&quot;Server received: &quot;</span> + message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在此代码中，我们简单地打印出收到的消息，并向客户端发送响应。</p>
<h5 id="关闭WebSocket连接"><a href="#关闭WebSocket连接" class="headerlink" title="关闭WebSocket连接"></a>关闭WebSocket连接</h5><p>在<code>@OnClose</code>方法中，可以删除连接并做一些清理工作。下面是一个示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@OnClose</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClose</span><span class="params">(Session session)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Connection closed: &quot;</span> + session.getId());</span><br><span class="line">    sessions.remove(session);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在此代码中，我们从连接池中删除连接，并打印出连接已关闭的消息。</p>
<h5 id="配置WebSocket支持"><a href="#配置WebSocket支持" class="headerlink" title="配置WebSocket支持"></a>配置WebSocket支持</h5><p>最后，需要配置Spring Boot以支持WebSocket。创建一个新的Java类，并添加注释<code>@Configuration</code>和<code>@EnableWebSocket</code>。然后，需要覆盖方法<code>registerWebSocketHandlers()</code>，并指定WebSocket处理程序。下面是一个示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.config.annotation.EnableWebSocket;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.config.annotation.WebSocketConfigurer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.config.annotation.WebSocketHandlerRegistry;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSocket</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSocketConfig</span> <span class="keyword">implements</span> <span class="title class_">WebSocketConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerWebSocketHandlers</span><span class="params">(WebSocketHandlerRegistry registry)</span> &#123;</span><br><span class="line">        registry.addHandler(<span class="keyword">new</span> <span class="title class_">WebSocketServer</span>(), <span class="string">&quot;/websocket&quot;</span>).setAllowedOrigins(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在此代码中，我们创建了一个新的<code>WebSocketServer</code>对象，并将其添加到WebSocket处理程序中。我们还指定了WebSocket端点（<code>/websocket</code>）和允许的来源（<code>*</code>）。</p>
<h3 id="四、-WebSocket的消息格式"><a href="#四、-WebSocket的消息格式" class="headerlink" title="四、 WebSocket的消息格式"></a>四、 WebSocket的消息格式</h3><h4 id="4-1-文本消息和二进制消息"><a href="#4-1-文本消息和二进制消息" class="headerlink" title="4.1 文本消息和二进制消息"></a>4.1 文本消息和二进制消息</h4><p>文本消息是普通的Unicode文本字符串。当WebSocket连接建立时，客户端和服务器可以通过发送文本消息来互相交换信息。服务器可以使用Session对象的<code>getBasicRemote()</code>方法来向客户端发送文本消息，客户端可以使用WebSocket的<code>send()</code>方法来向服务器发送文本消息。</p>
<p>下面是向客户端发送文本消息的示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">session.getBasicRemote().sendText(<span class="string">&quot;Hello, client!&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>二进制消息可以是任意类型的数据，包括图像、音频、视频等。要向客户端发送二进制消息，服务器可以使用Session对象的<code>getBasicRemote()</code>方法，将消息作为ByteBuffer对象发送。客户端可以使用WebSocket的send()方法来向服务器发送二进制消息。</p>
<p>下面是向客户端发送二进制消息的示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span>[] data = <span class="comment">// binary data</span></span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.wrap(data);</span><br><span class="line">session.getBasicRemote().sendBinary(buffer);</span><br></pre></td></tr></table></figure>

<p>请注意，尽管文本消息和二进制消息在格式上有所不同，但它们都是通过WebSocket发送的消息类型，因此客户端和服务器都需要能够处理这两种类型的消息。</p>
<h4 id="4-2-Ping和Pong消息"><a href="#4-2-Ping和Pong消息" class="headerlink" title="4.2 Ping和Pong消息"></a>4.2 Ping和Pong消息</h4><p>WebSocket还支持Ping和Pong消息类型，用于检测WebSocket连接是否仍然处于活动状态。Ping消息由客户端发送到服务器，Pong消息由服务器发送回客户端作为响应。如果客户端在一段时间内没有收到Pong消息，则它可以假定WebSocket连接已断开，并关闭连接。</p>
<p>要发送Ping消息，请使用Session对象的<code>getBasicRemote()</code>方法，并将Ping消息作为ByteBuffer对象发送。客户端可以使用WebSocket的<code>sendPing()</code>方法来向服务器发送Ping消息。</p>
<p>下面是向客户端发送Ping消息的示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ByteBuffer</span> <span class="variable">pingMessage</span> <span class="operator">=</span> ByteBuffer.wrap(<span class="keyword">new</span> <span class="title class_">byte</span>[] &#123; <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span> &#125;);</span><br><span class="line">session.getBasicRemote().sendPing(pingMessage);</span><br></pre></td></tr></table></figure>

<p>要接收Pong消息，请在您的WebSocket处理程序中实现<code>onPong()</code>方法。当您的WebSocket服务器接收到Pong消息时，它将自动调用此方法，并将接收到的Pong消息作为ByteBuffer对象传递给它。</p>
<p>下面是实现onPong()方法的示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@OnMessage</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onPong</span><span class="params">(Session session, ByteBuffer pongMessage)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Received Pong message: &quot;</span> + pongMessage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意，Ping和Pong消息通常用于WebSocket连接的健康检查。如果您希望在WebSocket连接中使用此功能，则应定期发送Ping消息并等待Pong消息的响应。</p>
<h4 id="4-3-关闭消息"><a href="#4-3-关闭消息" class="headerlink" title="4.3 关闭消息"></a>4.3 关闭消息</h4><p>WebSocket还支持关闭消息类型，用于关闭WebSocket连接。关闭消息可以由客户端或服务器发起，并且可以携带一个可选的状态码和关闭原因。当WebSocket连接关闭时，客户端和服务器都应该发送一个关闭消息以结束连接。</p>
<p>要发送关闭消息，请使用Session对象的<code>getBasicRemote()</code>方法，并调用它的<code>sendClose()</code>方法。关闭消息可以携带一个可选的状态码和关闭原因。如果您不希望发送状态码或关闭原因，则可以将它们设置为0和null。</p>
<p>下面是向客户端发送关闭消息的示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">session.close(<span class="keyword">new</span> <span class="title class_">CloseReason</span>(CloseReason.CloseCodes.NORMAL_CLOSURE, <span class="string">&quot;Closing from client.&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>要处理接收到的关闭消息，请在您的WebSocket处理程序中实现<code>onClose()</code>方法。当您的WebSocket服务器接收到关闭消息时，它将自动调用此方法，并将接收到的状态码和关闭原因传递给它。</p>
<p>下面是实现<code>onClose()</code>方法的示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@OnClose</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClose</span><span class="params">(Session session, CloseReason closeReason)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Connection closed: &quot;</span> + closeReason.getCloseCode() + <span class="string">&quot; - &quot;</span> + closeReason.getReasonPhrase());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意，客户端和服务器都应该发送关闭消息以结束WebSocket连接。如果只有一方发送了关闭消息，则另一方可能无法正确地关闭连接，并且可能需要等待超时才能释放资源。建议客户端和服务器在关闭连接时都发送关闭消息，以确保连接正确地关闭。</p>
<h3 id="五、-WebSocket的性能"><a href="#五、-WebSocket的性能" class="headerlink" title="五、 WebSocket的性能"></a>五、 WebSocket的性能</h3><h4 id="5-1-与传统的HTTP请求-响应模型比较"><a href="#5-1-与传统的HTTP请求-响应模型比较" class="headerlink" title="5.1 与传统的HTTP请求&#x2F;响应模型比较"></a>5.1 与传统的HTTP请求&#x2F;响应模型比较</h4><ul>
<li><strong>双向通信性能更好：</strong> WebSocket协议使用单一的TCP连接，允许客户端和服务器在同一个连接上进行双向通信。这种实时的双向通信可以更快地传输数据，而不需要建立多个HTTP请求&#x2F;响应连接。</li>
<li><strong>更小的网络流量：</strong> 与HTTP相比，WebSocket协议需要更少的网络流量来维护连接，因为它不需要在每个请求&#x2F;响应交换中发送头部信息。</li>
<li><strong>更低的延迟：</strong> WebSocket协议允许服务器主动向客户端推送消息，而不需要客户端先发送请求。这种实时通信可以减少响应延迟，并提高应用程序的性能。</li>
<li><strong>更好的服务器资源管理：</strong> 由于WebSocket连接可以保持活动状态，服务器可以更好地管理客户端连接，减少服务器开销和处理时间。</li>
</ul>
<p>WebSocket协议的性能比传统的HTTP请求&#x2F;响应模型更好，特别是在实时通信和低延迟方面。WebSocket协议适用于需要实时通信和实时数据更新的应用程序，如在线聊天、多人游戏、实时监控等。</p>
<h4 id="5-2-优化WebSocket的性能"><a href="#5-2-优化WebSocket的性能" class="headerlink" title="5.2 优化WebSocket的性能"></a>5.2 优化WebSocket的性能</h4><ul>
<li><strong>减少消息大小：</strong> WebSocket 传输的数据大小对性能有很大影响。尽量减少消息的大小，可以降低网络带宽和服务器负载。例如，可以使用二进制传输协议来代替文本传输，或使用压缩算法对消息进行压缩。</li>
<li><strong>使用CDN加速：</strong> 使用 CDN（内容分发网络）可以将静态资源缓存到离用户更近的节点上，提高传输速度和性能。CDN 可以缓存 Websocket 的初始握手请求，避免不必要的网络延迟。</li>
<li><strong>使用负载均衡：</strong> WebSocket 服务可以使用负载均衡来分配并平衡多个服务器的负载。负载均衡可以避免单个服务器被过载，并提高整个服务的可伸缩性。</li>
<li><strong>优化服务端代码：</strong> WebSocket 服务端代码的性能也是关键因素。使用高效的框架和算法，避免使用过多的内存和 CPU 资源，可以提高服务端的性能和响应速度。</li>
<li><strong>避免网络阻塞：</strong> WebSocket 的性能也会受到网络阻塞的影响。当有太多的连接同时请求数据时，服务器的性能会下降。使用合适的线程池和异步 IO 操作可以避免网络阻塞，提高 WebSocket 服务的并发性能。</li>
</ul>
<h3 id="六、-WebSocket的扩展应用和未来发展方向"><a href="#六、-WebSocket的扩展应用和未来发展方向" class="headerlink" title="六、 WebSocket的扩展应用和未来发展方向"></a>六、 WebSocket的扩展应用和未来发展方向</h3><ul>
<li><strong>更加完善的标准规范：</strong> WebSocket 标准规范还有很多可以优化的地方，未来可能会继续完善 WebSocket 的标准规范，以适应更加复杂的应用场景。</li>
<li><strong>更加安全的通信方式：</strong> 由于 WebSocket 的开放性，使得它可能会受到一些安全威胁，未来可能会通过加密、身份验证等方式来增强 WebSocket 的安全性。</li>
<li><strong>更好的兼容性：</strong> WebSocket 协议需要在 HTTP 协议的基础上建立连接，因此可能会遇到兼容性问题，未来可能会通过技术手段来解决这些问题。</li>
<li><strong>更好的性能和可伸缩性：</strong> WebSocket 协议的性能和可伸缩性对于复杂的应用场景非常关键，未来可能会通过技术手段来进一步提高 WebSocket 的性能和可伸缩性。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/03/28/WebSocket/" data-id="cm8sja97v003z8ktbew81e05p" data-title="WebSocket" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Web/" rel="tag">Web</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2025/03/15/Docker%E5%AE%89%E8%A3%85/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">后一篇</strong>
      <div class="article-nav-title">Docker安装</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Docker/">Docker</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript/">JavaScript</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Shell%E8%84%9A%E6%9C%AC/">Shell脚本</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Unity3D/">Unity3D</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Unreal-Engine/">Unreal Engine</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Web/">Web</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/git/">git</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Docker/" rel="tag">Docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Shell/" rel="tag">Shell</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Springboot/" rel="tag">Springboot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Unity3D/" rel="tag">Unity3D</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Unreal-Engine/" rel="tag">Unreal Engine</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue/" rel="tag">Vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web/" rel="tag">Web</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/" rel="tag">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/Docker/" style="font-size: 16px;">Docker</a> <a href="/tags/JavaScript/" style="font-size: 18px;">JavaScript</a> <a href="/tags/Linux/" style="font-size: 16px;">Linux</a> <a href="/tags/Shell/" style="font-size: 10px;">Shell</a> <a href="/tags/Springboot/" style="font-size: 18px;">Springboot</a> <a href="/tags/Unity3D/" style="font-size: 14px;">Unity3D</a> <a href="/tags/Unreal-Engine/" style="font-size: 12px;">Unreal Engine</a> <a href="/tags/Vue/" style="font-size: 12px;">Vue</a> <a href="/tags/Web/" style="font-size: 14px;">Web</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 18px;">算法</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 20px;">设计模式</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/03/">三月 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/01/">一月 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/12/">十二月 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/03/28/WebSocket/">WebSocket</a>
          </li>
        
          <li>
            <a href="/2025/03/15/Docker%E5%AE%89%E8%A3%85/">Docker安装</a>
          </li>
        
          <li>
            <a href="/2025/03/15/Docker%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/">Docker项目部署</a>
          </li>
        
          <li>
            <a href="/2025/03/15/Docker%E5%9F%BA%E7%A1%80/">Docker基础</a>
          </li>
        
          <li>
            <a href="/2025/03/15/Docker%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/">Docker快速入门</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 Lzh<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>